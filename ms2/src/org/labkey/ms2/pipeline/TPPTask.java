/*
 * Copyright (c) 2007-2008 LabKey Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.labkey.ms2.pipeline;

import org.apache.commons.lang.StringUtils;
import org.labkey.api.pipeline.*;
import org.labkey.api.util.FileType;
import org.labkey.api.util.NetworkDrive;
import org.fhcrc.cpas.exp.xml.SimpleTypeNames;

import java.io.File;
import java.io.IOException;
import java.io.FileNotFoundException;
import java.sql.SQLException;
import java.util.*;
import java.util.Arrays;

/**
 * <code>TPPTask</code> PipelineJob task to run the TPP (xinteract) for further
 * analysis on a pepXML file generated by running a pepXML converter on a search
 * engine's raw output.  This task may run PeptideProphet, ProteinProphet,
 * Quantitation, and batch fractions into a single pepXML.
 */
public class TPPTask extends PipelineJob.Task<TPPTask.Factory>
{
    public static final FileType FT_PEP_XML = new FileType(".pep.xml");
    public static final FileType FT_PROT_XML = new FileType(".prot.xml");
    public static final FileType FT_INTERMEDIATE_PROT_XML = new FileType(".pep-prot.xml");
    public static final FileType FT_TPP_PROT_XML = new FileType("-prot.xml");

    private static final FileType FT_PEP_XSL = new FileType(".pep.xsl");
    private static final FileType FT_PEP_SHTML = new FileType(".pep.shtml");
    private static final FileType FT_INTERMEDIATE_PROT_XSL = new FileType(".pep-prot.xsl");
    private static final FileType FT_INTERMEDIATE_PROT_SHTML = new FileType(".pep-prot.shtml");

    private static final String PEPTIDE_PROPHET_ACTION_NAME = "PeptideProphet";
    private static final String PROTEIN_PROPHET_ACTION_NAME = "ProteinProphet";
    private static final String PEPTIDE_QUANITATION_ACTION_NAME = "Peptide Quantitation";
    private static final String PROTEIN_QUANITATION_ACTION_NAME = "Protein Quantitation";

    public static File getPepXMLFile(File dirAnalysis, String baseName)
    {
        return FT_PEP_XML.newFile(dirAnalysis, baseName);
    }

    public static boolean isPepXMLFile(File file)
    {
        return FT_PEP_XML.isType(file);
    }

    public static File getProtXMLFile(File dirAnalysis, String baseName)
    {
        return FT_PROT_XML.newFile(dirAnalysis, baseName);
    }

    public static boolean isProtXMLFile(File file)
    {
        return (FT_PROT_XML.isType(file) ||
                FT_INTERMEDIATE_PROT_XML.isType(file) ||
                FT_TPP_PROT_XML.isType(file));
    }

    public static FileType getProtXMLFileType(File file)
    {
        if (FT_PROT_XML.isType(file))
        {
            return FT_PROT_XML;
        }
        if (FT_INTERMEDIATE_PROT_XML.isType(file))
        {
            return FT_INTERMEDIATE_PROT_XML;
        }
        if (FT_TPP_PROT_XML.isType(file))
        {
            return FT_TPP_PROT_XML;
        }
        return null;
    }

    public static File getProtXMLIntermediatFile(File dirAnalysis, String baseName)
    {
        return FT_INTERMEDIATE_PROT_XML.newFile(dirAnalysis, baseName);
    }

    /**
     * Interface for support required from the PipelineJob to run this task,
     * beyond the base PipelineJob methods.
     */
    public interface JobSupport extends MS2PipelineJobSupport
    {
        /**
         * List of pepXML files to use as inputs to "xinteract".
         */
        File[] getInteractInputFiles();

        /**
         * List of mzXML files to use as inputs to "xinteract" quantitation.
         */
        File[] getInteractSpectraFiles();

        /**
         * True if PeptideProphet and ProteinProphet can be run on the input files.
         */
        boolean isProphetEnabled();

        /**
         * True if RefreshParser should run.
         */
        boolean isRefreshRequired();
    }

    public static class Factory extends AbstractTaskFactory<AbstractTaskFactorySettings, Factory>
    {
        public Factory()
        {
            super(TPPTask.class);
        }

        public Factory(String name)
        {
            super(TPPTask.class, name);    
        }

        public PipelineJob.Task createTask(PipelineJob job)
        {
            return new TPPTask(this, job);
        }

        public FileType[] getInputTypes()
        {
            return new FileType[] { FT_PEP_XML };
        }

        public String getStatusName()
        {
            return "ANALYSIS";
        }

        public boolean isParticipant(PipelineJob job) throws IOException, SQLException
        {
            return job.getJobSupport(JobSupport.class).isSamples();
        }

        public boolean isJobComplete(PipelineJob job) throws IOException, SQLException
        {
            JobSupport support = job.getJobSupport(JobSupport.class);
            String baseName = support.getBaseName();
            File dirAnalysis = support.getAnalysisDirectory();

            if (!NetworkDrive.exists(getPepXMLFile(dirAnalysis, baseName)))
                return false;

            return !support.isProphetEnabled() || NetworkDrive.exists(getProtXMLFile(dirAnalysis, baseName));

        }

        public List<String> getProtocolActionNames()
        {
            return Arrays.asList(PEPTIDE_PROPHET_ACTION_NAME, PEPTIDE_QUANITATION_ACTION_NAME, PROTEIN_PROPHET_ACTION_NAME, PROTEIN_QUANITATION_ACTION_NAME);
        }

        public String getGroupParameterName()
        {
            return "tpp";
        }
    }

    public static class FactoryJoin extends Factory
    {
        public FactoryJoin()
        {
            super("join");
            
            setJoin(true);
        }

        public boolean isParticipant(PipelineJob job) throws IOException, SQLException
        {
            return job.getJobSupport(JobSupport.class).isFractions();
        }
    }

    protected TPPTask(Factory factory, PipelineJob job)
    {
        super(factory, job);
    }

    public JobSupport getJobSupport()
    {
        return getJob().getJobSupport(JobSupport.class);
    }

    public List<RecordedAction> run() throws PipelineJobException
    {
        try
        {
            Map<String, String> params = getJob().getParameters();

            WorkDirFactory factory = PipelineJobService.get().getWorkDirFactory();
            WorkDirectory wd = factory.createWorkDirectory(getJob().getJobGUID(), getJobSupport(), getJob().getLogger());

            List<RecordedAction> actions = new ArrayList<RecordedAction>();

            // First step takes all the pepXMLs as inputs and either runs PeptideProphet (non-join) or rolls them up (join)
            RecordedAction pepXMLAction = new RecordedAction(PEPTIDE_PROPHET_ACTION_NAME);
            actions.add(pepXMLAction);

            // Set mzXML directory only if needed.
            File dirMzXml = null;

            // TODO: mzXML files may be required, and input disk space requirements
            //          may be too great to copy to a temporary directory.
            File[] inputFiles = getJobSupport().getInteractInputFiles();
            File[] inputWorkFiles = new File[inputFiles.length];
            for (File fileInput : inputFiles)
            {
                pepXMLAction.addInput(fileInput, "RawPepXML");
            }

            if (inputFiles.length > 0)
            {
                WorkDirectory.CopyingResource lock = null;
                try
                {
                    lock = wd.ensureCopyingLock();
                    for (int i = 0; i < inputFiles.length; i++)
                        inputWorkFiles[i] = wd.inputFile(inputFiles[i], false);

                    if (isSpectraProcessor(params))
                    {
                        File[] spectraFiles = getJobSupport().getInteractSpectraFiles();
                        for (int i = 0; i < spectraFiles.length; i++)
                        {
                            spectraFiles[i] = wd.inputFile(spectraFiles[i], false);
                            if (dirMzXml == null)
                                dirMzXml = spectraFiles[i].getParentFile();
                        }
                    }
                }
                finally
                {
                    if (lock != null) { lock.release(); }
                }
            }

            RecordedAction peptideQuantAction = null;
            String[] quantParams = null;

            if (dirMzXml != null)
            {
                quantParams = getQuantitationCmd(params, wd.getRelativePath(dirMzXml));
                if (quantParams != null)
                {
                    peptideQuantAction = new RecordedAction(PEPTIDE_QUANITATION_ACTION_NAME);
                    String algorithm = getQuantitionAlgorithm(params);
                    peptideQuantAction.setDescription(algorithm + " " + peptideQuantAction.getName());
                    peptideQuantAction.addParameter(new RecordedAction.ParameterType("Quantitation algorithm", "terms.labkey.org#QuantitationAlgorithm", SimpleTypeNames.STRING), algorithm);
                    actions.add(peptideQuantAction);
                }
            }

            File fileWorkPepXML = wd.newFile(FT_PEP_XML);
            File fileWorkProtXML = null;
            RecordedAction protXMLAction = null;
            if (getJobSupport().isProphetEnabled())
            {
                fileWorkProtXML = wd.newFile(FT_INTERMEDIATE_PROT_XML);

                // Second step optionally runs ProteinProphet on the pepXML
                protXMLAction = new RecordedAction(PROTEIN_PROPHET_ACTION_NAME);
                actions.add(protXMLAction);
            }

            String ver = getJob().getParameters().get("pipeline, tpp version");
            List<String> interactCmd = new ArrayList<String>();
            interactCmd.add(PipelineJobService.get().getExecutablePath("xinteract", "tpp", ver));

            if (!getJobSupport().isProphetEnabled())
            {
                interactCmd.add("-nP"); // no Prophet analysis
            }
            else
            {
                StringBuffer prophetOpts = new StringBuffer("-Opt");
                if ("yes".equalsIgnoreCase(params.get("pipeline prophet, accurate mass")))
                    prophetOpts.append("A");
                if ("yes".equalsIgnoreCase(params.get("pipeline prophet, allow multiple instruments")))
                    prophetOpts.append("w");

                if (!"2.9.9".equals(ver))
                {
                    interactCmd.add("-x20");    // 20 iterations extra for good measure.
                    
                    if (!"3.0.2".equals(ver))
                    {
                        // prophetOpts.append("F");
                        if ("yes".equalsIgnoreCase(params.get("pipeline prophet, use hydrophobicity")))
                            prophetOpts.append("R");
                        if ("yes".equalsIgnoreCase(params.get("pipeline prophet, use pI")))
                            prophetOpts.append("I");
                        String decoyTag = params.get("pipeline prophet, decoy tag");
                        if (decoyTag != null && !"".equals(decoyTag))
                            interactCmd.add("-d" + decoyTag);
                    }
                }

                interactCmd.add(prophetOpts.toString());

                if (!getJobSupport().isRefreshRequired())
                    interactCmd.add("-nR");

                String paramMinProb = params.get("pipeline prophet, min probability");
                if (paramMinProb == null || paramMinProb.length() == 0)
                    paramMinProb = params.get("pipeline prophet, min peptide probability");
                if (paramMinProb != null && paramMinProb.length() > 0)
                    interactCmd.add("-p" + paramMinProb);
                
                paramMinProb = params.get("pipeline prophet, min protein probability");
                if (paramMinProb != null && paramMinProb.length() > 0)
                    interactCmd.add("-pr" + paramMinProb);
            }

            RecordedAction proteinQuantAction = null;

            if (quantParams != null && getJobSupport().isProphetEnabled())
            {
                proteinQuantAction = new RecordedAction(PROTEIN_QUANITATION_ACTION_NAME);
                String algorithm = getQuantitionAlgorithm(params);
                proteinQuantAction.setDescription(algorithm + " " + proteinQuantAction.getName());
                proteinQuantAction.addParameter(new RecordedAction.ParameterType("Quantitation algorithm", "terms.labkey.org#QuantitationAlgorithm", SimpleTypeNames.STRING), algorithm);
                actions.add(proteinQuantAction);
            }

            interactCmd.add("-N" + fileWorkPepXML.getName());

            for (File fileInput : inputWorkFiles)
                interactCmd.add(wd.getRelativePath(fileInput));

            getJob().runSubProcess(new ProcessBuilder(interactCmd), wd.getDir());

            WorkDirectory.CopyingResource lock = null;
            try
            {
                lock = wd.ensureCopyingLock();
                File filePepXML = wd.outputFile(fileWorkPepXML);
                File fileProtXML = wd.outputFile(fileWorkProtXML, FT_PROT_XML.getName(getJobSupport().getBaseName()));

                // Set up the first step with the right outputs
                pepXMLAction.addOutput(filePepXML, "PepXML", false);

                // Set up the second step with the right inputs and outputs
                protXMLAction.addInput(filePepXML, "PepXML");
                protXMLAction.addOutput(fileProtXML, "ProtXML", false);

                if (peptideQuantAction != null)
                {
                    for (File file : getJobSupport().getInteractSpectraFiles())
                    {
                        peptideQuantAction.addInput(file, "mzXML");
                    }
                    peptideQuantAction.addInput(filePepXML, "PepXML");
                    peptideQuantAction.addOutput(filePepXML, "QuantPepXML", false);
                }

                if (proteinQuantAction != null)
                {
                    proteinQuantAction.addInput(fileProtXML, "ProtXML");
                    proteinQuantAction.addInput(filePepXML, "PepXML");
                    proteinQuantAction.addOutput(fileProtXML, "QuantProtXML", false);
                }
            }
            finally
            {
                if (lock != null) { lock.release(); }
            }

            // Deal with possible TPP outputs, if TPP was not XML_ONLY
            wd.discardFile(wd.newFile(FT_PEP_XSL));
            wd.discardFile(wd.newFile(FT_PEP_SHTML));
            wd.discardFile(wd.newFile(FT_INTERMEDIATE_PROT_XSL));
            wd.discardFile(wd.newFile(FT_INTERMEDIATE_PROT_SHTML));
            wd.remove();

            // If no combined analysis is coming or this is the combined analysis, remove
            // the raw pepXML file(s).
            if (!getJobSupport().isFractions() || inputFiles.length > 1)
            {
                for (File fileInput : inputFiles)
                {
                    if (!fileInput.delete())
                        getJob().warn("Failed to delete intermediate file " + fileInput);
                }
            }

            // TODO - optional third step for quantitation. Need to figure out how to say that a step touches an output without claiming that it created it

            // All the programs are launched through the same XInteract command, so set the same command line on them all
            for (RecordedAction action : actions)
            {
                action.addParameter(RecordedAction.COMMAND_LINE_PARAM, StringUtils.join(interactCmd, " "));
            }

            return actions;
        }
        catch (IOException e)
        {
            throw new PipelineJobException(e);
        }
    }

    private boolean isSpectraProcessor(Map<String, String> params)
    {
        // Spectrum file(s) required to do quantitation.
        return (getQuantitionAlgorithm(params) != null);
    }
    
    private String getQuantitionAlgorithm(Map<String, String> params)
    {
        String paramAlgorithm = params.get("pipeline quantitation, algorithm");
        if (paramAlgorithm == null)
            return null;
        if (!"q3".equalsIgnoreCase(paramAlgorithm) && !"xpress".equalsIgnoreCase(paramAlgorithm))
            return null;    // CONSIDER: error message.
        return paramAlgorithm;
    }

    private String[] getQuantitationCmd(Map<String, String> params, String pathMzXml) throws FileNotFoundException
    {
        String paramAlgorithm = getQuantitionAlgorithm(params);
        if (paramAlgorithm == null)
            return null;

        List<String> quantOpts = new ArrayList<String>();

        String paramQuant = params.get("pipeline quantitation, residue label mass");
        if (paramQuant != null)
            getLabelOptions(paramQuant, quantOpts);

        paramQuant = params.get("pipeline quantitation, mass tolerance");
        if (paramQuant != null)
            quantOpts.add("-m" + paramQuant);

        paramQuant = params.get("pipeline quantitation, heavy elutes before light");
        if (paramQuant != null)
            if("yes".equalsIgnoreCase(paramQuant))
                quantOpts.add("-b");

        paramQuant = params.get("pipeline quantitation, fix");
        if (paramQuant != null)
        {
            if ("heavy".equalsIgnoreCase(paramQuant))
                quantOpts.add("-H");
            else if ("light".equalsIgnoreCase(paramQuant))
                quantOpts.add("-L");
        }

        paramQuant = params.get("pipeline quantitation, fix elution reference");
        if (paramQuant != null)
        {
            String refFlag = "-f";
            if ("peak".equalsIgnoreCase(paramQuant))
                refFlag = "-F";
            paramQuant = params.get("pipeline quantitation, fix elution difference");
            if (paramQuant != null)
                quantOpts.add(refFlag + paramQuant);
        }

        paramQuant = params.get("pipeline quantitation, metabolic search type");
        if (paramQuant != null)
        {
            if ("normal".equalsIgnoreCase(paramQuant))
                quantOpts.add("-M");
            else if ("heavy".equalsIgnoreCase(paramQuant))
                quantOpts.add("-N");
        }

        quantOpts.add("\"-d" + pathMzXml + "\"");

        if ("xpress".equals(paramAlgorithm))
            return new String[] { "-X" + StringUtils.join(quantOpts.iterator(), ' ') };

        String paramMinPP = params.get("pipeline quantitation, min peptide prophet");
        if (paramMinPP != null)
            quantOpts.add("--minPeptideProphet=" + paramMinPP);
        String paramMaxDelta = params.get("pipeline quantitation, max fractional delta mass");
        if (paramMaxDelta != null)
            quantOpts.add("--maxFracDeltaMass=" + paramMaxDelta);
        String paramCompatQ3 = params.get("pipeline quantitation, q3 compat");
        if ("yes".equalsIgnoreCase(paramCompatQ3))
            quantOpts.add("--compat");

        String ver = params.get("pipeline, msinspect ver");
        
        // TODO: Doesn't work when JAVA_HOME has a space in the path
        return new String[] {
                "-C1" + PipelineJobService.get().getJavaPath() + " -client -Xmx256M -jar "
                + "" + PipelineJobService.get().getJarPath("viewerApp.jar", "msinspect", ver) + ""
                + " --q3 " + StringUtils.join(quantOpts.iterator(), ' ')
                ,
                "-C2Q3ProteinRatioParser"
        };
    }

    private void getLabelOptions(String paramQuant, List<String> quantOpts)
    {
        String[] quantSpecs = paramQuant.split(",");
        for (String spec : quantSpecs)
        {
            String[] specVals = spec.split("@");
            if (specVals.length != 2)
                continue;
            String mass = specVals[0].trim();
            String aa = specVals[1].trim();
            quantOpts.add("-n" + aa + "," + mass);
        }
    }
}
