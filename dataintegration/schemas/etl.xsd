<?xml version="1.0" encoding="UTF-8"?>
<schema xmlns="http://www.w3.org/2001/XMLSchema"
        xmlns:etl="http://labkey.org/etl/xml"
        targetNamespace="http://labkey.org/etl/xml"
        elementFormDefault="qualified"
        attributeFormDefault="unqualified">

    <import namespace="http://labkey.org/pipeline/xml" schemaLocation="../../../../schemas/pipelineTasks.xsd"/>

    <element name="etl" type="etl:EtlType"/>


    <complexType name="EtlType">
        <all>
            <element name="name" type="string" maxOccurs="1"/>
            <element name="description" type="string" maxOccurs="1" minOccurs="0"/>
            <element name="transforms" type="etl:TransformsType" maxOccurs="1"/>
            <element name="schedule" type="etl:ScheduleType" maxOccurs="1" minOccurs="0"/>
            <element name="incrementalFilter" type="etl:FilterType" minOccurs="0" maxOccurs="1"/>
            <element name="parameters" type="etl:ParametersType" minOccurs="0" maxOccurs="1"/>
        </all>
        <attribute name="loadReferencedFiles" type="boolean" default="false"/>
    </complexType>

    <complexType name="SourceObjectType">
        <attribute name="schemaName" type="string" use="required"/>
        <attribute name="queryName" type="string" use="required"/>
        <attribute name="timestampColumnName" type="string" use="optional"/>
        <attribute name="sourceOption" type="etl:SourceOptionType" use="optional"/>
        <attribute name="remoteSource" type="string" use="optional"/>
        <attribute name="useTransaction" type="boolean" use="optional" default="true">
            <annotation>
                <documentation>Wrap selecting from source query in a transaction. Only used for simple query transform types.</documentation>
            </annotation>
        </attribute>
    </complexType>

    <complexType name="TargetObjectType">
        <annotation>
            <documentation>Targets will be of type 'query' (the default), or 'file'. For query, the schemaName and queryName attributes are required. For file, the fileBaseName and fileExtension attributes are required.</documentation>
        </annotation>
        <attribute name="schemaName" type="string" use="optional"/>
        <attribute name="queryName" type="string" use="optional"/>
        <attribute name="bulkLoad" type="boolean" use="optional">
            <annotation>
                <documentation>Bulk loads minimize the logging for auditing purposes and other overhead.</documentation>
            </annotation>
        </attribute>
        <attribute name="dir" type="string" use="optional"/>
        <attribute name="fileBaseName" type="string" use="optional">
            <annotation>
                <documentation>The base name to use for an output target table. Special substitutions:<p/>'${TransformRunId}' will be substituted with the transformRunId.<p/>'${Timestamp}' will be substituted with the timestamp at file creation.</documentation>
            </annotation>
        </attribute>
        <attribute name="fileExtension" type="string" use="optional">
            <annotation>
                <documentation>Optional (required for pipeline usage), the extension for the output target table. A leading dot is optional; there will always be a dot separator between the file basename and extension</documentation>
            </annotation>
        </attribute>
        <attribute name="columnDelimiter" type="string" use="optional"/>
        <attribute name="quote" type="string" use="optional">
            <annotation>
                <documentation>Character to qualify text when a field contains the column or row delimiter</documentation>
            </annotation>
        </attribute>
        <attribute name="rowDelimiter" type="string" use="optional"/>
        <attribute name="targetOption" type="etl:TargetOptionType" use="optional" default="append"/>
        <attribute name="type" type="etl:TargetTypeType" use="optional" default="query"/>
        <attribute name="useTransaction" type="boolean" use="optional" default="true">
            <annotation>
                <documentation>Wrap writing to target query in a transaction. Not used when target is a file.</documentation>
            </annotation>
        </attribute>
        <attribute name="transactionSize" type="nonNegativeInteger" use="optional" default="0">
            <annotation>
                <documentation>Incrementally commit target transaction every n rows instead of in a single wrapping transaction.</documentation>
            </annotation>
        </attribute>
    </complexType>

    <simpleType name ="SourceOptionType">
        <restriction base="string">
            <enumeration value="deleteRowsAfterSelect"/>
            <!-- TODO: This has not yet been implemented . -->
        </restriction>
    </simpleType>

    <simpleType name="TargetOptionType">
        <restriction base="string">
            <enumeration value="merge"/>
            <enumeration value="append"/>
            <enumeration value="truncate"/>
        </restriction>
    </simpleType>

    <simpleType name="TargetTypeType">
        <restriction base="string">
            <enumeration value="query"/>
            <enumeration value="file">
                <annotation>
                    <documentation>The target will be a file of basename and extension specified by fileBaseName and fileExtension.
                         By default the field and row separators will be for a tsv file, but this can be overridden with optional columnDelimiter and rowDelimiter attributes.
                        For ETLs that use the target file as input to a pipeline command tasks, it is possible to skip running the command task for a 0 row file. Use the "etlOutputHadRows"
                        parameter in the pipeline configuration. See nlpContext.xml for an example of this.
                    </documentation>
                </annotation>
            </enumeration>
        </restriction>
    </simpleType>

    <complexType name="SchemaProcedureType">
        <sequence minOccurs="0" maxOccurs="unbounded">
            <element name="parameter" type="etl:ProcedureParameterType"/>
        </sequence>
        <attribute name="schemaName" type="string" use="required"/>
        <attribute name="procedureName" type="string" use="required"/>
        <attribute name="useTransaction" type="boolean" use="optional" default="true">
            <annotation>
                <documentation>Wrap the call of the procedure in a transaction.</documentation>
            </annotation>
        </attribute>
    </complexType>

    <complexType name="ProcedureParameterType">
        <attribute name="name" type="string" use="required"/>
        <attribute name="value" type="string" use="optional"/>
        <attribute name="override" type="boolean" use="optional" default="false"/>
        <attribute name="scope" type="etl:ProcedureParameterScopeType" use="optional" default="local"/>
    </complexType>

    <simpleType name="ProcedureParameterScopeType">
        <annotation>
            <documentation>These match two of the scopes defined in the Variable Map persisted in the TransformConfiguration.TransformState field. (We don't support the notion of a 'parent' scope here.) Globally scoped parameters allow sharing/passing of context across multiple stored procedure steps.</documentation>
        </annotation>
        <restriction base="string">
            <enumeration value="local"/>
            <enumeration value="global"/>
        </restriction>
    </simpleType>

    <complexType name="TransformsType">
        <sequence minOccurs="0" maxOccurs="unbounded">
            <element name="transform" type="etl:TransformType"/>
        </sequence>
    </complexType>

    <complexType name="TransformType">
      <all>
        <!-- <element name="properties" type="etl:PropertiesType" minOccurs="0" maxOccurs="1"/> -->
        <element name="description" type="string" minOccurs="0" />
        <element name="source" type="etl:SourceObjectType" minOccurs="0"/>
        <element name="destination" type="etl:TargetObjectType" minOccurs="0"/>
        <element name="procedure" type="etl:SchemaProcedureType" minOccurs="0"/>
        <element name="taskref" type="etl:TaskRefType" maxOccurs="1" minOccurs="0"/>
      </all>
      <attribute name="id" type="string" use="required"/>
        <attribute name="type" type="string" default="SimpleQueryTransformStep"/>
        <attribute name="file" type="string"/>
        <attribute name="streaming" type="boolean" default="true"/>
        <attribute name="externalTaskId" type="string"/>
    </complexType>

<!-- <complexType name="PropertiesType">
        <all>
            <element name="property" type="string" minOccurs="0"/>
        </all>
    </complexType>

    <complexType name="PropertyType">
        <attribute name="name" type="string" use="required"/>
        <attribute name="value" type="string" use="required"/>
    </complexType>
-->

    <complexType name="ScheduleType">
        <all>
            <element name="poll" type="etl:PollType" minOccurs="0"/>
            <element name="cron" type="etl:CronType" minOccurs="0"/>
        </all>
    </complexType>


    <complexType name="PollType">
        <attribute name="interval" type="string" use="required"/>
    </complexType>


    <complexType name="CronType">
        <attribute name="expression" type="string" use="required"/>
    </complexType>


    <complexType name="FilterType">
        <!-- <all>
            <element name="properties" type="etl:PropertiesType" minOccurs="0"/>
        </all> -->

        <attribute name="className" type="etl:FilterClassType" use="optional"/>

        <!-- TODO: temp removing this attribute until it is implemented. Intended to be an in-app configurable override to the filter strategy
        <attribute name="selectAll" type="boolean" use="optional"/>
        -->

        <!-- org.labkey.di.filters.ModifiedSinceFilterStrategy -->
        <attribute name="timestampColumnName" type="string" use="optional"/>

        <!-- org.labkey.di.filters.RunFilterStrategy -->
        <attribute name="runTableSchema" type="string" use="optional"/>
        <attribute name="runTable" type="string" use="optional"/>
        <attribute name="pkColumnName" type="string" use="optional"/>
        <attribute name="fkColumnName" type="string" use="optional"/>
    </complexType>

    <simpleType name="FilterClassType">
        <restriction base="string">
            <enumeration value="RunFilterStrategy"/>
            <enumeration value="ModifiedSinceFilterStrategy"/>
            <enumeration value="SelectAllFilterStrategy"/>
        </restriction>
    </simpleType>

    <complexType name="ParametersType">
        <sequence minOccurs="0" maxOccurs="unbounded">
            <element name="parameter" type="etl:ParameterType"/>
        </sequence>
    </complexType>

    <complexType name="ParameterType">
        <attribute name="name" type="string" use="required" />
        <attribute name="value" type="string" use="optional" />
        <attribute name="type" type="string" use="required" />
    </complexType>

    <complexType name="TaskRefType">
        <sequence>
            <element name="settings" type="etl:SettingsType" minOccurs="0" maxOccurs="1"/>
        </sequence>
        <attribute name="ref" type="string" use="required"/>
    </complexType>

    <complexType name="SettingsType">
        <sequence>
            <element name="setting" type="etl:SettingType" minOccurs="0" maxOccurs="unbounded"/>
        </sequence>
    </complexType>

    <complexType name="SettingType">
        <attribute name="name" type="string" use="required"/>
        <attribute name="value" type="string" use="required"/>
    </complexType>

</schema>
